// Copyright 2014, Catlike Coding, http://catlikecoding.com
using UnityEngine;
using System;

namespace CatlikeCoding.NumberFlow {

	/// <summary>
	/// Link between a NumberFlow diagram and materials.
	/// </summary>
	[Serializable]
	public sealed class DiagramMaterialLink {

		/// <summary>
		/// NumberFlow diagram.
		/// </summary>
		public Diagram diagram;

		/// <summary>
		/// Materials whose textures should be generated by the diagram.
		/// </summary>
		public Material[] materials;

		/// <summary>
		/// Settings for the generated textures.
		/// </summary>
		public DiagramTextureSettings textureSettings;

		/// <summary>
		/// Generated textures.
		/// </summary>
		[NonSerialized]
		public Texture[] textures;

		/// <summary>
		/// Current cubemap direction.
		/// </summary>
		[NonSerialized]
		public CubemapFace currentDirection;

		private static TextureFormat[] normalTextureFormats = {
#if UNITY_EDITOR || !(UNITY_IPHONE || UNITY_ANDROID || UNITY_BLACKBERRY || UNITY_WP8)
			TextureFormat.ARGB32,
#else
			TextureFormat.RGB24,
#endif
			TextureFormat.ARGB32,
			TextureFormat.RGB24,
			TextureFormat.ARGB32
		};

		/// <summary>
		/// Get whether the link currently has generated textures assigned to its materials.
		/// </summary>
		public bool HasAssignedTextures {
			get {
				return
					materials.Length > 0 &&
					materials[0] != null &&
					materials[0].GetTexture(diagram.outputs[0].name) != null;
			}
		}

		/// <summary>
		/// Create the texture objects but do not fill them yet.
		/// </summary>
		public void AllocateTextures () {
			if (diagram == null) {
				textures = new Texture[0];
				return;
			}

			textures = new Texture[diagram.outputs.Length];
			for (int i = 0; i < textures.Length; i++) {
				TextureFormat format;
				bool linear = textureSettings.linear;
				switch (diagram.outputs[i].type) {
					case DiagramTextureType.ARGB: format = TextureFormat.ARGB32; break;
					case DiagramTextureType.RGB: format = TextureFormat.RGB24; break;
					case DiagramTextureType.Alpha: format = TextureFormat.Alpha8; break;
					default: // DiagramTextureType.NormalMap
						format = normalTextureFormats[(int)textureSettings.normalFormat];
						linear = true;
						break;
				}
				Texture t;
				if (diagram.isCubemap) {
					t = new Cubemap(textureSettings.width, format, textureSettings.mipmap);
				}
				else {
					t = new Texture2D(textureSettings.width, textureSettings.height, format, textureSettings.mipmap, linear);
				}
				t.name = "Managed NumberFlow Diagram Texture";
				t.hideFlags = HideFlags.HideAndDontSave;
				t.filterMode = textureSettings.filterMode;
				t.wrapMode = textureSettings.wrapMode;
				t.anisoLevel = textureSettings.anisoLevel;
				textures[i] = t;
			}
		}

		/// <summary>
		/// Clean up textures.
		/// </summary>
		public void OnDestroy () {
			if (diagram == null || textures == null) {
				return;
			}
			for (int m = 0; m < materials.Length; m++) {
				Material material = materials[m];
				if (material != null) {
					for (int o = 0; o < diagram.outputs.Length; o++) {
						material.SetTexture(diagram.outputs[o].name, null);
					}
				}
			}
			for (int i = 0; i < textures.Length; i++) {
#if UNITY_EDITOR
				GameObject.DestroyImmediate(textures[i]);
#else
				GameObject.Destroy(textures[i]);
#endif
			}
			textures = null;
		}

		/// <summary>
		/// Initialize the buffers, fill and postprocess the textures.
		/// </summary>
		/// <param name="buffers">Pixel buffers.</param>
		public void Process (ref Color[][] buffers) {
			InitBuffers(ref buffers);
			diagram.cubemapDirection = currentDirection;
			int height = diagram.isCubemap ? textureSettings.width : textureSettings.height;
			diagram.Fill(buffers, textureSettings.width, height);
			diagram.PostProcess(buffers, textureSettings.width, height, textureSettings.normalFormat);
		}

		/// <summary>
		/// Initialize the buffers.
		/// </summary>
		/// <param name="buffers">Pixel buffers.</param>
		public void InitBuffers (ref Color[][] buffers) {
			if (buffers.Length < textures.Length) {
				Array.Resize(ref buffers, textures.Length);
			}
			int textureSize = textureSettings.width * (diagram.isCubemap ? textureSettings.width : textureSettings.height);
			for (int i = 0; i < textures.Length; i++) {
				if (buffers[i] == null) {
					buffers[i] = new Color[textureSize];
				}
				else if (buffers[i].Length < textureSize) {
					Array.Resize(ref buffers[i], textureSize);
				}
			}
		}

		/// <summary>
		/// Fill the specified rows of all textures. Return whether the last row was filled.
		/// </summary>
		/// <returns>Whether filling is done.</returns>
		/// <param name="buffers">Pixel buffers.</param>
		/// <param name="rowIndex">Row index to start from.</param>
		/// <param name="rowCount">How many rows to fill.</param>
		public bool FillRows (Color[][] buffers, ref int rowIndex, int rowCount) {
			if (diagram.isCubemap) {
				diagram.cubemapDirection = currentDirection;
			}
			int height = diagram.isCubemap ? textureSettings.width : textureSettings.height;
			rowIndex = diagram.FillRows(buffers, textureSettings.width, height, rowIndex, rowCount);
			if (rowIndex >= height) {
				if (diagram.isCubemap) {
					rowIndex = 0;
					AssignCubemapFaces(buffers);
					if (currentDirection == CubemapFace.NegativeZ) {
						return true;
					}
					currentDirection += 1;
				}
				else {
					return true;
				}
			}
			return false;
		}

		/// <summary>
		/// Assigns color buffer data to cubemap faces.
		/// </summary>
		/// <param name="buffers">Pixel buffers.</param>
		public void AssignCubemapFaces (Color[][] buffers) {
			for (int i = 0; i < textures.Length; i++) {
				Color[] buffer = buffers[i];

				if (!textureSettings.linear && QualitySettings.activeColorSpace == ColorSpace.Linear) {
					// Generated cubemaps are always in linear space.
					// Have to convert to linear color space.
					for (int p = 0; p < buffer.Length; p++) {
						buffer[p] = buffer[p].linear;
					}
				}

				Cubemap cubemap = textures[i] as Cubemap;
				cubemap.SetPixels(buffer, currentDirection);
			}
		}

		/// <summary>
		/// Post process the buffers for all textures.
		/// </summary>
		/// <param name="buffers">Pixel buffers.</param>
		public void PostProcess (Color[][] buffers) {
			diagram.PostProcess(
				buffers,
				textureSettings.width, diagram.isCubemap ? textureSettings.width : textureSettings.height,
				textureSettings.normalFormat
			);
		}

		/// <summary>
		/// Apply the pixel buffers to all textures.
		/// </summary>
		/// <param name="buffers">Pixel buffers.</param>
		public void ApplyTextures (Color[][] buffers) {
			if (diagram.isCubemap) {
				for (int i = 0; i < textures.Length; i++) {
					(textures[i] as Cubemap).Apply(true, true);
				}
			}
			else {
				for (int i = 0; i < textures.Length; i++) {
					(textures[i] as Texture2D).SetPixels(buffers[i]);
					(textures[i] as Texture2D).Apply(true, true);
				}
			}
		}

		/// <summary>
		/// Assign all textures to all materials.
		/// </summary>
		public void AssignTexturesToMaterials () {
			if (diagram == null || textures == null) {
				return;
			}

			for (int m = 0; m < materials.Length; m++) {
				Material material = materials[m];
				if (material != null) {
					for (int o = 0; o < diagram.outputs.Length; o++) {
						material.SetTexture(diagram.outputs[o].name, textures[o]);
					}
				}
			}
		}
	}
}